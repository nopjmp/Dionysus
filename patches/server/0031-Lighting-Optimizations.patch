From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: nopjmp <kthompson@hey.com>
Date: Fri, 12 Mar 2021 23:08:53 -0600
Subject: [PATCH] Lighting Optimizations

Semi-Experimental as this gets rid of lambda creations and replaces it with only a single allocation of a Triple in one path.

Additionally remove some sync'd functions.

diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index c4ee23505544528694e422a3293ef44bf037fb66..861c3e2223dc3d1f9a62137cd7f87c7b4d52562c 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -143,7 +143,7 @@ public class PaperWorldConfig {
 
     public boolean queueLightUpdates;
     private void queueLightUpdates() {
-        queueLightUpdates = getBoolean("queue-light-updates", false);
+        queueLightUpdates = getBoolean("queue-light-updates", true);
         log("Lighting Queue enabled: " + queueLightUpdates);
     }
 
diff --git a/src/main/java/dev/pomf/dionysus/DionysusConfig.java b/src/main/java/dev/pomf/dionysus/DionysusConfig.java
index 0c19a39380182907d34037d6283f86ca84c79d03..510ddb4f8167c9c9a70df3ba0ead1ff754563613 100644
--- a/src/main/java/dev/pomf/dionysus/DionysusConfig.java
+++ b/src/main/java/dev/pomf/dionysus/DionysusConfig.java
@@ -163,6 +163,11 @@ public class DionysusConfig {
         return config.getStringList(key);
     }
 
+    public static long maxLightTimePerTick;
+    private static void maxLightTimePerTickMs() {
+        maxLightTimePerTick = getInt("light-updates-max-ms-per-tick", 30) * 1000000L;
+    }
+
     public static boolean customNameAiLimitBypass = true;
     public static boolean tamableAiLimitBypass = true;
     public static boolean spawnerAiLimitBypass = true;
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 5f81b78c3dd37917dff3079fdcf4957a66763ef3..ac7186fc85839cbe7e196f4272b1be82d6110036 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -2,16 +2,16 @@ package net.minecraft.server;
 
 import com.destroystokyo.paper.exception.ServerInternalException;
 import com.google.common.base.Predicate;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import javax.annotation.Nullable;
+
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -64,7 +64,7 @@ public class Chunk {
             return removed;
         }
     }
-    final PaperLightingQueue.LightingQueue lightingQueue = new PaperLightingQueue.LightingQueue(this);
+    final DionysusLightingQueue.LightingQueue lightingQueue = new DionysusLightingQueue.LightingQueue(this);
     // Paper end
     private boolean done;
     private boolean lit;
@@ -77,7 +77,7 @@ public class Chunk {
     private int x;
     private final ConcurrentLinkedQueue<BlockPosition> y;
     public boolean d; public void setShouldUnload(boolean unload) { this.d = unload; } public boolean isUnloading() { return d; } // Paper - OBFHELPER
-    protected gnu.trove.map.hash.TObjectIntHashMap<Class> entityCount = new gnu.trove.map.hash.TObjectIntHashMap<Class>(); // Spigot
+    protected Object2IntOpenHashMap<Class<? extends IAnimal>> entityCount = new Object2IntOpenHashMap<>(); // Dionysus - use fastutil instead of trove // Spigot
 
     // Paper start
     // Track the number of minecarts and items
@@ -538,22 +538,8 @@ public class Chunk {
                 if (flag) {
                     this.initLighting();
                 } else {
-                    this.runOrQueueLightUpdate(() -> { // Paper - Queue light update
-                    int j1 = iblockdata.c();
-                    int k1 = iblockdata1.c();
-
-                    if (j1 > 0) {
-                        if (j >= i1) {
-                            this.c(i, j + 1, k);
-                        }
-                    } else if (j == i1 - 1) {
-                        this.c(i, j, k);
-                    }
-
-                    if (j1 != k1 && (j1 < k1 || this.getBrightness(EnumSkyBlock.SKY, blockposition) > 0 || this.getBrightness(EnumSkyBlock.BLOCK, blockposition) > 0)) {
-                        this.d(i, k);
-                    }
-                    }); // Paper
+                    // Paper - Queue light update
+                    runOrQueueLightReplacementUpdate(blockposition, iblockdata, iblockdata1);
                 }
 
                 TileEntity tileentity;
@@ -588,6 +574,32 @@ public class Chunk {
         }
     }
 
+    // Dionysus start - extract out light function for block replacement
+    public void updateReplacementLight(BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1) {
+        int i = blockposition.getX() & 15;
+        int j = blockposition.getY();
+        int k = blockposition.getZ() & 15;
+        int l = k << 4 | i;
+
+        int i1 = this.heightMap[l];
+
+        int j1 = iblockdata.c();
+        int k1 = iblockdata1.c();
+
+        if (j1 > 0) {
+            if (j >= i1) {
+                this.c(i, j + 1, k);
+            }
+        } else if (j == i1 - 1) {
+            this.c(i, j, k);
+        }
+
+        if (j1 != k1 && (j1 < k1 || this.getBrightness(EnumSkyBlock.SKY, blockposition) > 0 || this.getBrightness(EnumSkyBlock.BLOCK, blockposition) > 0)) {
+            this.d(i, k);
+        }
+    }
+    // Dionysus end
+
     public int getBrightness(EnumSkyBlock enumskyblock, BlockPosition blockposition) {
         int i = blockposition.getX() & 15;
         int j = blockposition.getY();
@@ -709,7 +721,7 @@ public class Chunk {
         {
             if ( creatureType.a().isAssignableFrom( entity.getClass() ) )
             {
-                this.entityCount.adjustOrPutValue( creatureType.a(), 1, 1 );
+                this.entityCount.addTo( creatureType.a(), 1);
             }
         }
         // Spigot end
@@ -755,7 +767,7 @@ public class Chunk {
         {
             if ( creatureType.a().isAssignableFrom( entity.getClass() ) )
             {
-                this.entityCount.adjustValue( creatureType.a(), -1 );
+                this.entityCount.addTo( creatureType.a(), -1 );
             }
         }
         // Spigot end
@@ -1481,16 +1493,26 @@ public class Chunk {
         this.w = i;
     }
 
+    // Dionysus start
     // Paper start
-    public void runOrQueueLightUpdate(Runnable runnable) {
+    public void runOrQueueLightUpdate(BlockPosition blockPosition) {
         if (this.world.paperConfig.queueLightUpdates) {
-            lightingQueue.add(runnable);
+            lightingQueue.add(blockPosition);
         } else {
-            runnable.run();
+            this.world.updateLightingAtBlockPos(blockPosition);
         }
     }
     // Paper end
 
+    public void runOrQueueLightReplacementUpdate(BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1) {
+        if (this.world.paperConfig.queueLightUpdates) {
+            lightingQueue.add(blockposition, iblockdata, iblockdata1);
+        } else {
+            this.updateReplacementLight(blockposition, iblockdata, iblockdata1);
+        }
+    }
+    // Dionysus end
+
     public static enum EnumTileEntityState {
 
         IMMEDIATE, QUEUED, CHECK;
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index ad5485908d3795e73f5fa13c0d553b7fde17c189..4ad9a824b671b2c83a594cb2ad9b98b36d423b46 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -1,31 +1,26 @@
 package net.minecraft.server;
 
-import com.destroystokyo.paper.PaperConfig;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import com.destroystokyo.paper.exception.ServerInternalException;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.objects.ObjectIterator;
+import it.unimi.dsi.fastutil.longs.LongArraySet;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
+import org.bukkit.event.world.ChunkUnloadEvent;
+
+import javax.annotation.Nullable;
 import java.io.IOException;
-import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Set;
-import javax.annotation.Nullable;
-import com.destroystokyo.paper.exception.ServerInternalException;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
-import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
-import org.bukkit.event.world.ChunkUnloadEvent;
 // CraftBukkit end
 
 public class ChunkProviderServer implements IChunkProvider {
 
     private static final Logger a = LogManager.getLogger();
-    public final Set<Long> unloadQueue = Sets.newHashSet();
+    public final LongArraySet unloadQueue = new LongArraySet(512); // Dionysus
     public final ChunkGenerator chunkGenerator;
     private final IChunkLoader chunkLoader;
     // Paper start - chunk save stats
@@ -34,25 +29,7 @@ public class ChunkProviderServer implements IChunkProvider {
     private long lastSaveStatPrinted = System.currentTimeMillis();
     // Paper end
     // Paper start
-    protected Chunk lastChunkByPos = null;
-    public Long2ObjectOpenHashMap<Chunk> chunks = new Long2ObjectOpenHashMap<Chunk>(8192) {
-
-        @Override
-        public Chunk get(long key) {
-            if (lastChunkByPos != null && key == lastChunkByPos.chunkKey) {
-                return lastChunkByPos;
-            }
-            return lastChunkByPos = super.get(key);
-        }
-
-        @Override
-        public Chunk remove(long key) {
-            if (lastChunkByPos != null && key == lastChunkByPos.chunkKey) {
-                lastChunkByPos = null;
-            }
-            return super.remove(key);
-        }
-    }; // CraftBukkit
+    public Long2ObjectOpenHashMap<Chunk> chunks = new Long2ObjectOpenHashMap<>(8192);
     // Paper end
     public final WorldServer world;
 
@@ -68,21 +45,16 @@ public class ChunkProviderServer implements IChunkProvider {
 
     public void unload(Chunk chunk) {
         if (this.world.worldProvider.c(chunk.locX, chunk.locZ)) {
-            this.unloadQueue.add(Long.valueOf(ChunkCoordIntPair.a(chunk.locX, chunk.locZ)));
+            this.unloadQueue.add(ChunkCoordIntPair.a(chunk.locX, chunk.locZ)); // Dionysus
             chunk.d = true;
         }
 
     }
 
     public void b() {
-        ObjectIterator objectiterator = this.chunks.values().iterator();
-
-        while (objectiterator.hasNext()) {
-            Chunk chunk = (Chunk) objectiterator.next();
-
+        for (Chunk chunk : this.chunks.values()) {
             this.unload(chunk);
         }
-
     }
 
     // Paper start
@@ -202,9 +174,9 @@ public class ChunkProviderServer implements IChunkProvider {
                 CrashReport crashreport = CrashReport.a(throwable, "Exception generating new chunk");
                 CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Chunk to be generated");
 
-                crashreportsystemdetails.a("Location", (Object) String.format("%d,%d", new Object[] { Integer.valueOf(i), Integer.valueOf(j)}));
-                crashreportsystemdetails.a("Position hash", (Object) Long.valueOf(k));
-                crashreportsystemdetails.a("Generator", (Object) this.chunkGenerator);
+                crashreportsystemdetails.a("Location", String.format("%d,%d", i, j));
+                crashreportsystemdetails.a("Position hash", k);
+                crashreportsystemdetails.a("Generator", this.chunkGenerator);
                 throw new ReportedException(crashreport);
             }
 
@@ -252,7 +224,7 @@ public class ChunkProviderServer implements IChunkProvider {
     }
 
     public void saveChunk(Chunk chunk, boolean unloaded) { // Spigot
-        try (co.aikar.timings.Timing timed = world.timings.chunkSaveData.startTiming()) {
+        try (co.aikar.timings.Timing ignored = world.timings.chunkSaveData.startTiming()) {
             chunk.setLastSaved(this.world.getTime());
             this.chunkLoader.saveChunk(this.world, chunk, unloaded); // Spigot
         } catch (IOException ioexception) {
@@ -304,14 +276,10 @@ public class ChunkProviderServer implements IChunkProvider {
         }
         final int autoSaveLimit = world.paperConfig.maxAutoSaveChunksPerTick;
         // Paper end
-        Iterator iterator = this.chunks.values().iterator();
-        while (iterator.hasNext()) {
-            Chunk chunk = (Chunk) iterator.next();
-            // CraftBukkit end
-
-            if (flag) {
-                this.saveChunkNOP(chunk);
-            }
+        for (Chunk chunk : this.chunks.values()) {
+//            if (flag) {
+//                this.saveChunkNOP(chunk);
+//            }
 
             if (chunk.a(flag)) {
                 this.saveChunk(chunk, false); // Spigot
@@ -341,12 +309,12 @@ public class ChunkProviderServer implements IChunkProvider {
                 int targetSize = Math.min(this.unloadQueue.size() - 100,  (int) (this.unloadQueue.size() * UNLOAD_QUEUE_RESIZE_FACTOR)); // Paper - Make more aggressive
                 // Spigot end
 
-                Iterator iterator = this.unloadQueue.iterator();
+                Iterator<Long> iterator = this.unloadQueue.iterator();
 
                 while (iterator.hasNext()) { // Spigot
-                    Long olong = (Long) iterator.next();
+                    long chunkKey = iterator.next();
                     iterator.remove(); // Spigot
-                    Chunk chunk = (Chunk) this.chunks.get(olong);
+                    Chunk chunk = this.chunks.get(chunkKey);
 
                     if (chunk != null && chunk.d) {
                         // CraftBukkit start - move unload logic to own method
@@ -414,7 +382,7 @@ public class ChunkProviderServer implements IChunkProvider {
         chunk.removeEntities();
         if (save) {
             this.saveChunk(chunk, true); // Spigot
-            this.saveChunkNOP(chunk);
+//            this.saveChunkNOP(chunk);
         }
         this.chunks.remove(chunk.chunkKey);
         return true;
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index e6906effb4bb63ec1b856ccb190434e0cb0a7510..ca2f4dcaac1646e05b10dee285967a17d4e9a25d 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -194,7 +194,7 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
         return this.processSaveQueueEntry(false);
     }
 
-    private synchronized boolean processSaveQueueEntry(boolean logCompletion) {
+    private boolean processSaveQueueEntry(boolean logCompletion) {
         // CraftBukkit start
         // Paper start - Chunk queue improvements
         QueuedChunk chunk = queue.poll();
diff --git a/src/main/java/net/minecraft/server/PaperLightingQueue.java b/src/main/java/net/minecraft/server/DionysusLightingQueue.java
similarity index 50%
rename from src/main/java/net/minecraft/server/PaperLightingQueue.java
rename to src/main/java/net/minecraft/server/DionysusLightingQueue.java
index f1c013116fc05b7abe7184eae01b715c02c7a058..33df884c049726c9ebaad7d61ba905ee6946611c 100644
--- a/src/main/java/net/minecraft/server/PaperLightingQueue.java
+++ b/src/main/java/net/minecraft/server/DionysusLightingQueue.java
@@ -1,28 +1,27 @@
 package net.minecraft.server;
 
 import co.aikar.timings.Timing;
+import dev.pomf.dionysus.DionysusConfig;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import org.apache.commons.lang3.tuple.Triple;
 
-import java.util.ArrayDeque;
-
-class PaperLightingQueue {
-    private static final long MAX_TIME = (long) (1000000000 / 20 * 1.15);
-
+final class DionysusLightingQueue {
     static void processQueue(long curTime) {
         final long startTime = System.nanoTime();
-        final long maxTickTime = MAX_TIME - (startTime - curTime);
+        final long maxTickTime = DionysusConfig.maxLightTimePerTick - (startTime - curTime);
 
         if (maxTickTime <= 0) {
             return;
         }
 
         START:
-        for (World world : MinecraftServer.getServer().worlds) {
+        for (WorldServer world : MinecraftServer.getServer().worlds) {
             if (!world.paperConfig.queueLightUpdates) {
                 continue;
             }
 
-            ObjectCollection<Chunk> loadedChunks = ((WorldServer) world).getChunkProviderServer().chunks.values();
+            ObjectCollection<Chunk> loadedChunks = world.getChunkProviderServer().chunks.values();
             for (Chunk chunk : loadedChunks.toArray(new Chunk[0])) {
                 if (chunk.lightingQueue.processQueue(startTime, maxTickTime)) {
                     break START;
@@ -31,8 +30,10 @@ class PaperLightingQueue {
         }
     }
 
-    static class LightingQueue extends ArrayDeque<Runnable> {
+    static final class LightingQueue {
         final private Chunk chunk;
+        final private ObjectArrayList<BlockPosition> updates = new ObjectArrayList<>();
+        final private ObjectArrayList<Triple<BlockPosition, IBlockData,  IBlockData>> replacementUpdates = new ObjectArrayList<>();
 
         LightingQueue(Chunk chunk) {
             super();
@@ -47,20 +48,35 @@ class PaperLightingQueue {
          * @return true to abort processing furthur lighting updates
          */
         private boolean processQueue(long startTime, long maxTickTime) {
-            if (this.isEmpty()) {
+            if (updates.isEmpty() && replacementUpdates.isEmpty()) {
                 return false;
             }
             if (isOutOfTime(maxTickTime, startTime)) {
                 return true;
             }
             try (Timing ignored = chunk.world.timings.lightingQueueTimer.startTiming()) {
-                Runnable lightUpdate;
-                while ((lightUpdate = this.poll()) != null) {
-                    lightUpdate.run();
+                int i;
+                for (i = 0; i < replacementUpdates.size(); i++) {
+                    if (isOutOfTime(maxTickTime, startTime)) {
+                        replacementUpdates.removeElements(0, i);
+                        return true;
+                    }
+
+                    Triple<BlockPosition, IBlockData,  IBlockData> triple = replacementUpdates.get(i);
+                    chunk.updateReplacementLight(triple.getLeft(), triple.getMiddle(), triple.getRight());
+                }
+                replacementUpdates.clear();
+
+                for (i = 0; i < updates.size(); i++) {
                     if (isOutOfTime(maxTickTime, startTime)) {
+                        updates.removeElements(0, i);
                         return true;
                     }
+
+                    BlockPosition blockPos = updates.get(i);
+                    chunk.world.updateLightingAtBlockPos(blockPos);
                 }
+                updates.clear();
             }
 
             return false;
@@ -73,7 +89,18 @@ class PaperLightingQueue {
             if (!chunk.world.paperConfig.queueLightUpdates) {
                 return;
             }
-            processQueue(0, 0); // No timeout
+
+            final long startTime = System.nanoTime();
+            final long maxTickTime = DionysusConfig.maxLightTimePerTick - (startTime - MinecraftServer.getServer().tickStartTime);
+
+            if (maxTickTime <= 0) {
+                return;
+            }
+
+            if (processQueue(startTime, maxTickTime)) {
+                // ran out of time
+                return;
+            }
 
             final int radius = 1;
             for (int x = chunk.locX - radius; x <= chunk.locX + radius; ++x) {
@@ -84,11 +111,22 @@ class PaperLightingQueue {
 
                     Chunk neighbor = MCUtil.getLoadedChunkWithoutMarkingActive(chunk.world, x, z);
                     if (neighbor != null) {
-                        neighbor.lightingQueue.processQueue(0, 0); // No timeout
+                        if (neighbor.lightingQueue.processQueue(startTime, maxTickTime)) {
+                            // ran out of time
+                            return;
+                        }
                     }
                 }
             }
         }
+
+        public void add(BlockPosition blockPosition) {
+            updates.add(blockPosition);
+        }
+
+        public void add(BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1) {
+            replacementUpdates.add(Triple.of(blockposition, iblockdata, iblockdata1));
+        }
     }
 
     private static boolean isOutOfTime(long maxTickTime, long startTime) {
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index aeeaccbba01e9fa13a98f580fa1025288c75fab9..df8940ff1c317ca321e0a03d06eafffd4b561c6c 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1,7 +1,6 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.ListenableFutureTask;
@@ -28,7 +27,6 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Queue;
 import java.util.Random;
@@ -36,7 +34,6 @@ import java.util.UUID;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
-import java.util.function.Supplier;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
 import org.apache.commons.lang3.Validate;
@@ -44,9 +41,6 @@ import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 // CraftBukkit start
 import joptsimple.OptionSet;
-import org.bukkit.Bukkit;
-import org.bukkit.craftbukkit.CraftServer;
-import org.bukkit.craftbukkit.Main;
 // CraftBukkit end
 import org.spigotmc.SlackActivityAccountant; // Spigot
 import co.aikar.timings.MinecraftTimings; // Paper
@@ -126,6 +120,10 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IAs
     public final SlackActivityAccountant slackActivityAccountant = new SlackActivityAccountant();
     // Spigot end
 
+    // Dionysus start
+    public Long tickStartTime;
+    // Dionysus end
+
     public MinecraftServer(OptionSet options, Proxy proxy, DataConverterManager dataconvertermanager, YggdrasilAuthenticationService yggdrasilauthenticationservice, MinecraftSessionService minecraftsessionservice, GameProfileRepository gameprofilerepository, UserCache usercache) {
         SERVER = this; // Paper - better singleton
         io.netty.util.ResourceLeakDetector.setEnabled( false ); // Spigot - disable
@@ -764,6 +762,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IAs
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.startTiming(); // Paper
         this.slackActivityAccountant.tickStarted(); // Spigot
         long i = System.nanoTime(); long startTime = i; // Paper
+        tickStartTime = startTime; // Dionysus
 
         ++this.ticks;
         if (this.T) {
@@ -832,7 +831,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IAs
         this.methodProfiler.b();
 
         org.spigotmc.WatchdogThread.tick(); // Spigot
-        PaperLightingQueue.processQueue(startTime); // Paper
+        DionysusLightingQueue.processQueue(startTime); // Paper
         this.slackActivityAccountant.tickEnded(tickNanos); // Spigot
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.stopTiming(); // Paper
     }
diff --git a/src/main/java/net/minecraft/server/SpawnerCreature.java b/src/main/java/net/minecraft/server/SpawnerCreature.java
index 5c5bed0344baeeaff4e75807326a7255ebca8bf5..3b001ae0ae2f15486285a19b3b301c77eefb57e1 100644
--- a/src/main/java/net/minecraft/server/SpawnerCreature.java
+++ b/src/main/java/net/minecraft/server/SpawnerCreature.java
@@ -1,50 +1,49 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Sets;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
-import java.util.Set;
 
 // CraftBukkit start
 import com.destroystokyo.paper.exception.ServerInternalException;
+import it.unimi.dsi.fastutil.longs.LongArraySet;
+import it.unimi.dsi.fastutil.longs.LongIterator;
 import org.bukkit.craftbukkit.util.LongHash;
-import org.bukkit.craftbukkit.util.LongHashSet;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 // CraftBukkit end
 
 public final class SpawnerCreature {
 
-    private static final int a = (int) Math.pow(17.0D, 2.0D);
-    private final LongHashSet b = new LongHashSet(); // CraftBukkit
+    //private static final int a = (int) Math.pow(17.0D, 2.0D);
+    private final LongArraySet b = new LongArraySet(); // CraftBukkit
 
     public SpawnerCreature() {}
 
     // Spigot start - get entity count only from chunks being processed in b
-    private int getEntityCount(WorldServer server, Class oClass)
+    private int getEntityCount(WorldServer server, Class<? extends IAnimal> oClass)
     {
         // Paper start - use entire world, not just active chunks. Spigot broke vanilla expectations.
-        if (true) {
+        //if (true) {
             int sum = 0;
             for (Chunk c : server.getChunkProviderServer().chunks.values()) {
-                sum += c.entityCount.get(oClass);
+                sum += c.entityCount.getInt(oClass);
             }
             return sum;
-        }
+        //}
         // Paper end
-        int i = 0;
-        Iterator<Long> it = this.b.iterator();
-        while ( it.hasNext() )
-        {
-            Long coord = it.next();
-            int x = LongHash.msw( coord );
-            int z = LongHash.lsw( coord );
-            if ( !((ChunkProviderServer)server.chunkProvider).unloadQueue.contains( coord ) && server.isChunkLoaded( x, z, true ) )
-            {
-                i += server.getChunkAt( x, z ).entityCount.get( oClass );
-            }
-        }
-        return i;
+//        int i = 0;
+//        LongIterator it = this.b.iterator();
+//        while ( it.hasNext() )
+//        {
+//            long coord = it.nextLong();
+//            int x = LongHash.msw( coord );
+//            int z = LongHash.lsw( coord );
+//            if ( !((ChunkProviderServer)server.chunkProvider).unloadQueue.contains( coord ) && server.isChunkLoaded( x, z, true ) )
+//            {
+//                i += server.getChunkAt( x, z ).entityCount.get( oClass );
+//            }
+//        }
+//        return i;
     }
     // Spigot end
 
@@ -55,19 +54,19 @@ public final class SpawnerCreature {
         } else {
             this.b.clear();
             int i = 0;
-            Iterator iterator = worldserver.players.iterator();
+            Iterator<EntityHuman> iterator = worldserver.players.iterator();
 
             int j;
             int k;
 
             while (iterator.hasNext()) {
-                EntityHuman entityhuman = (EntityHuman) iterator.next();
+                EntityHuman entityhuman = iterator.next();
 
                 if (!entityhuman.isSpectator() && entityhuman.affectsSpawning) {
                     int l = MathHelper.floor(entityhuman.locX / 16.0D);
 
                     j = MathHelper.floor(entityhuman.locZ / 16.0D);
-                    boolean flag3 = true;
+                    //boolean flag3 = true;
                     // Spigot Start
                     byte b0 = worldserver.spigotConfig.mobSpawnRange;
                     b0 = ( b0 > worldserver.spigotConfig.viewDistance ) ? (byte) worldserver.spigotConfig.viewDistance : b0;
@@ -86,14 +85,16 @@ public final class SpawnerCreature {
                         for (k = -b0; k <= b0; ++k) {
                             boolean flag4 = i1 == -b0 || i1 == b0 || k == -b0 || k == b0;
                             // Spigot End
-                            ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i1 + l, k + j);
+                            // Dionysus start - remove use of temporary objects that are not needed.
+                            int x = i1 + l;
+                            int z = k + j;
 
                             // CraftBukkit start - use LongHash and LongHashSet
-                            long chunkCoords = LongHash.toLong(chunkcoordintpair.x, chunkcoordintpair.z);
+                            long chunkCoords = LongHash.toLong(x, z);
                             if (!this.b.contains(chunkCoords)) {
                                 ++i;
-                                if (!flag4 && worldserver.getWorldBorder().isInBounds(chunkcoordintpair)) {
-                                    PlayerChunk playerchunk = worldserver.getPlayerChunkMap().getChunk(chunkcoordintpair.x, chunkcoordintpair.z);
+                                if (!flag4 && worldserver.getWorldBorder().isChunkInBounds(x, z)) {
+                                    PlayerChunk playerchunk = worldserver.getPlayerChunkMap().getChunk(x, z);
 
                                     if (playerchunk != null && playerchunk.e()) {
                                         this.b.add(chunkCoords);
@@ -101,6 +102,7 @@ public final class SpawnerCreature {
                                     }
                                 }
                             }
+                            // Dionysus end
                         }
                     }
                 }
@@ -135,7 +137,7 @@ public final class SpawnerCreature {
                 if (limit == 0) {
                     continue;
                 }
-				int mobcnt = 0; // Spigot
+				int mobcnt; // Spigot
                 // CraftBukkit end
 
                 if ((!enumcreaturetype.d() || flag1) && (enumcreaturetype.d() || flag) && (!enumcreaturetype.e() || flag2)) {
@@ -146,13 +148,13 @@ public final class SpawnerCreature {
 
                     if ((mobcnt = getEntityCount(worldserver, enumcreaturetype.a())) <= limit * i / 289) { // Paper - use 17x17 like vanilla (a at top of file)
                         BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
-                        Iterator iterator1 = this.b.iterator();
+                        LongIterator iterator1 = this.b.iterator();
 
                         int moblimit = (limit * i / 256) - mobcnt + 1; // Spigot - up to 1 more than limit
                         label120:
                         while (iterator1.hasNext() && (moblimit > 0)) { // Spigot - while more allowed
                             // CraftBukkit start = use LongHash and LongObjectHashMap
-                            long key = ((Long) iterator1.next()).longValue();
+                            long key = iterator1.nextLong();
                             BlockPosition blockposition1 = getRandomPosition(worldserver, LongHash.msw(key), LongHash.lsw(key));
                             // CraftBukkit
                             int i2 = blockposition1.getX();
@@ -166,9 +168,8 @@ public final class SpawnerCreature {
 
                                 while (i3 < 3) {
                                     int j3 = i2;
-                                    int k3 = j2;
                                     int l3 = k2;
-                                    boolean flag5 = true;
+                                    //boolean flag5 = true;
                                     BiomeBase.BiomeMeta biomebase_biomemeta = null;
                                     GroupDataEntity groupdataentity = null;
                                     int i4 = MathHelper.f(Math.random() * 4.0D);
@@ -178,13 +179,14 @@ public final class SpawnerCreature {
                                         if (j4 < i4) {
                                             label113: {
                                                 j3 += worldserver.random.nextInt(6) - worldserver.random.nextInt(6);
-                                                k3 += worldserver.random.nextInt(1) - worldserver.random.nextInt(1);
+                                                // Dionysus - this is always 0
+                                                //k3 += worldserver.random.nextInt(1) - worldserver.random.nextInt(1);
                                                 l3 += worldserver.random.nextInt(6) - worldserver.random.nextInt(6);
-                                                blockposition_mutableblockposition.c(j3, k3, l3);
+                                                blockposition_mutableblockposition.c(j3, j2, l3);
                                                 float f = (float) j3 + 0.5F;
                                                 float f1 = (float) l3 + 0.5F;
 
-                                                if (worldserver.getWorldBorder().isInBounds(blockposition_mutableblockposition) && worldserver.getChunkIfLoaded(blockposition_mutableblockposition) != null && !worldserver.isPlayerNearby((double) f, (double) k3, (double) f1, 24.0D) && blockposition.distanceSquared((double) f, (double) k3, (double) f1) >= 576.0D) { // Paper - Prevent mob spawning from loading/generating chunks
+                                                if (worldserver.getWorldBorder().isInBounds(blockposition_mutableblockposition) && worldserver.getChunkIfLoaded(blockposition_mutableblockposition) != null && !worldserver.isPlayerNearby(f, j2, f1, 24.0D) && blockposition.distanceSquared(f, j2, f1) >= 576.0D) { // Paper - Prevent mob spawning from loading/generating chunks
                                                     if (biomebase_biomemeta == null) {
                                                         biomebase_biomemeta = worldserver.a(enumcreaturetype, (BlockPosition) blockposition_mutableblockposition);
                                                         if (biomebase_biomemeta == null) {
@@ -215,14 +217,14 @@ public final class SpawnerCreature {
                                                         EntityInsentient entityinsentient;
 
                                                         try {
-                                                            entityinsentient = (EntityInsentient) biomebase_biomemeta.b.getConstructor(new Class[] { World.class}).newInstance(new Object[] { worldserver});
+                                                            entityinsentient = biomebase_biomemeta.b.getConstructor(new Class[] { World.class}).newInstance(worldserver);
                                                         } catch (Exception exception) {
                                                             exception.printStackTrace();
                                                             ServerInternalException.reportInternalException(exception); // Paper
                                                             return j1;
                                                         }
 
-                                                        entityinsentient.setPositionRotation((double) f, (double) k3, (double) f1, worldserver.random.nextFloat() * 360.0F, 0.0F);
+                                                        entityinsentient.setPositionRotation(f, j2, f1, worldserver.random.nextFloat() * 360.0F, 0.0F);
                                                         if (entityinsentient.P() && entityinsentient.canSpawn()) {
                                                             groupdataentity = entityinsentient.prepare(worldserver.D(new BlockPosition(entityinsentient)), groupdataentity);
                                                             if (entityinsentient.canSpawn()) {
@@ -305,11 +307,11 @@ public final class SpawnerCreature {
     }
 
     public static void a(World world, BiomeBase biomebase, int i, int j, int k, int l, Random random) {
-        List list = biomebase.getMobs(EnumCreatureType.CREATURE);
+        List<BiomeBase.BiomeMeta> list = biomebase.getMobs(EnumCreatureType.CREATURE);
 
         if (!list.isEmpty()) {
             while (random.nextFloat() < biomebase.f()) {
-                BiomeBase.BiomeMeta biomebase_biomemeta = (BiomeBase.BiomeMeta) WeightedRandom.a(world.random, list);
+                BiomeBase.BiomeMeta biomebase_biomemeta = WeightedRandom.a(world.random, list);
                 int i1 = biomebase_biomemeta.c + random.nextInt(1 + biomebase_biomemeta.d - biomebase_biomemeta.c);
                 GroupDataEntity groupdataentity = null;
                 int j1 = i + random.nextInt(k);
@@ -327,7 +329,7 @@ public final class SpawnerCreature {
                             EntityInsentient entityinsentient;
 
                             try {
-                                entityinsentient = (EntityInsentient) biomebase_biomemeta.b.getConstructor(new Class[] { World.class}).newInstance(new Object[] { world});
+                                entityinsentient = biomebase_biomemeta.b.getConstructor(new Class[] { World.class}).newInstance(world);
                             } catch (Exception exception) {
                                 exception.printStackTrace();
                                 ServerInternalException.reportInternalException(exception); // Paper
diff --git a/src/main/java/net/minecraft/server/StructureGenerator.java b/src/main/java/net/minecraft/server/StructureGenerator.java
index f4dfba8f315c7f88fdda4ff1639314d7d38099a9..97f18572be414c1fa9fc5c5f4cfccd776472713c 100644
--- a/src/main/java/net/minecraft/server/StructureGenerator.java
+++ b/src/main/java/net/minecraft/server/StructureGenerator.java
@@ -22,7 +22,7 @@ public abstract class StructureGenerator extends WorldGenBase {
     public String getName() { return a(); } // Paper // OBFHELPER
     public abstract String a();
 
-    protected final synchronized void a(World world, final int i, final int j, int k, int l, ChunkSnapshot chunksnapshot) {
+    protected final void a(World world, final int i, final int j, int k, int l, ChunkSnapshot chunksnapshot) {
         this.a(world);
         if (!this.c.containsKey(ChunkCoordIntPair.a(i, j))) {
             this.f.nextInt();
@@ -75,7 +75,7 @@ public abstract class StructureGenerator extends WorldGenBase {
         }
     }
 
-    public synchronized boolean a(World world, Random random, ChunkCoordIntPair chunkcoordintpair) {
+    public boolean a(World world, Random random, ChunkCoordIntPair chunkcoordintpair) {
         timing.startTiming(); // Paper
         this.a(world);
         int i = (chunkcoordintpair.x << 4) + 8;
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index ad20107495936cd4424cb6e671a1c0c9dc3447d5..dbb371f3e93c5fd318c2c4f069d6437d2e8744b7 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -413,7 +413,7 @@ public abstract class World implements IBlockAccess {
             } else {
                 if (iblockdata.c() != iblockdata1.c() || iblockdata.d() != iblockdata1.d()) {
                     this.methodProfiler.a("checkLight");
-                    chunk.runOrQueueLightUpdate(() -> this.w(blockposition)); // Paper - Queue light update
+                    chunk.runOrQueueLightUpdate(blockposition); // Paper - Queue light update
                     this.methodProfiler.b();
                 }
 
@@ -2409,6 +2409,7 @@ public abstract class World implements IBlockAccess {
         }
     }
 
+    public boolean updateLightingAtBlockPos(BlockPosition blockPosition) { return this.w(blockPosition); } // Dionysus - OBFHELPER
     public boolean w(BlockPosition blockposition) {
         boolean flag = false;
 
